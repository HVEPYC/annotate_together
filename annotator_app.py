# Annotator App generated by Gemini 2.5 Pro and CVPR Group 5 "Strix Halo"
# ===========================================================================================================
# Annotator logic devised and prompt engineered by Harishankar Vinod
# Github annotations management programmed by Harishankar Vinod

# Necessary Imports
import dearpygui.dearpygui as dpg
from PIL import Image
import numpy as np
import json
import os
import glob
import math
import datetime
from collections import defaultdict # Useful for loading
import shutil
import git

# --- Configuration ---
GIT_OUTPUT_DIR = "annotations"
GIT_ANNOTATION_FILENAME = "annotations.json"
OUTPUT_DIR = "temp_annotations"
ANNOTATION_FILENAME = "temp_annotations.json"
SUPPORTED_EXTENSIONS = ['.png', '.jpg', '.jpeg', '.bmp', '.gif', '.tiff']
MIN_PLOT_HEIGHT = 720.0
IMAGE_SUBDIR = "images_dir"
DEFAULT_LANGUAGE_SCORE = 10

# --- Annotator Specific Info ---
TASK_TYPES = ["caption", "vqa", "instruction"]
SPLIT_TYPES = ["train", "val", "test"]
DIFFICULTY_LEVELS = ["easy", "medium", "hard"]

# --- Function for Git Repo Management
def pull_repo_new():
    git.Repo.clone_from("https://github.com/HVEPYC/annotations",GIT_OUTPUT_DIR)

def pull_repo_exist():
    annotations_git = git.cmd.Git(GIT_OUTPUT_DIR)
    annotations_git.pull()

def pull_annotations_repo():
    print("Pulling latest Annotations from GitHub")
    """Pulls the latest annotations file from Github"""
    if os.path.exists(GIT_OUTPUT_DIR) == False:
        pull_repo_new()
    else:
        pull_repo_exist()
    print("Latest annotations pulled from GitHub")

# Before anything is done, clone the Annotations repo or pull latest changes
pull_annotations_repo()

# Then go ahead with remaining program work

# --- Global State ---
# Annotation related state for CURRENT image & SELECTED entry
points = [] # For drawing the current bbox
rectangles = [] # Internal bbox list for the SELECTED annotation entry

# Overall annotation state (NEW STRUCTURE)
# { "filename.png": [ {annotation_dict_1}, {annotation_dict_2}, ... ], ... }
all_annotations = {}

# State for current image editing
current_image_index = -1
selected_directory = ""
# --- > NEW: Index of the selected annotation entry for the current image ---
selected_annotation_index = -1 # -1 means none selected/loaded

# Persistent state across images
annotator_id_value = ""
source_value = ""

# Image/Display related state
texture_id = None
image_width = 0; image_height = 0
display_width = 0; display_height = 0
image_files = []

# DPG Item IDs / Tags
plot_id = "image_plot"; xaxis_id = "plot_xaxis"; yaxis_id = "plot_yaxis"
status_text_id = "status_text"; filename_text_id = "filename_text"
drawn_items = []
texture_registry_id = "texture_registry"; current_texture_tag = "image_texture"; drawn_image_tag = "plot_image"
main_window_tag = "main_window"; directory_dialog_tag = "directory_dialog"

# Input Field Tags
annotator_id_input = "annotator_id_input"; source_input = "source_input"
task_type_combo = "task_type_combo"; split_combo = "split_combo"; difficulty_combo = "difficulty_combo"
text_ms_input = "text_ms_input"; answer_ms_input = "answer_ms_input"
text_en_input = "text_en_input"; answer_en_input = "answer_en_input"
tags_input = "tags_input"; lang_score_input = "lang_score_input"

# --- > NEW: UI Tags for Multi-Entry Management ---
annotation_entry_combo = "annotation_entry_combo"
new_entry_button = "new_entry_button"
delete_entry_button = "delete_entry_button"

# --- Helper Functions ---
def create_output_dir(): os.makedirs(OUTPUT_DIR, exist_ok=True)
def get_annotation_filepath(): return os.path.join(OUTPUT_DIR, ANNOTATION_FILENAME)

def get_current_filename():
    """Returns the filename of the currently loaded image, or None."""
    if 0 <= current_image_index < len(image_files):
        return os.path.basename(image_files[current_image_index])
    return None

# --- > MODIFIED: Load annotations into the new dictionary structure ---
def load_existing_annotations():
    global all_annotations
    filepath = get_annotation_filepath()
    all_annotations = {} # Reset
    if os.path.exists(filepath):
        try:
            with open(filepath, 'r') as f:
                loaded_list = json.load(f)

            # Group by filename derived from image_path
            grouped_annotations = defaultdict(list)

            for item in loaded_list:
                image_path = item.get("image_path", "")
                image_id = item.get("image_id")

                if not image_path or not image_id:
                    print(f"Warning: Skipping annotation due to missing image_path/image_id: {item}")
                    continue

                # # Basic check for overall duplicate image_ids
                # if image_id in image_ids_seen_overall:
                #      print(f"Warning: Duplicate image_id '{image_id}' found across dataset. Check data integrity. Skipping duplicate entry.")
                #      continue
                # image_ids_seen_overall.add(image_id)

                # Derive filename (handle potential path separator differences)
                filename = os.path.basename(image_path.replace(f"{IMAGE_SUBDIR}/", "").replace(f"{IMAGE_SUBDIR}\\", ""))
                if not filename:
                    print(f"Warning: Could not derive filename from image_path: {image_path}")
                    continue

                grouped_annotations[filename].append(item)

            all_annotations = dict(grouped_annotations) # Convert back to regular dict
            print(f"Loaded {len(loaded_list)} annotations for {len(all_annotations)} images from {filepath}")

        except Exception as e:
            print(f"Error loading annotations file {filepath}: {e}")
            all_annotations = {}
    else:
        print("No existing annotation file found. Starting fresh.")
        all_annotations = {}

def update_status(message):
    if status_text_id and dpg.does_item_exist(status_text_id): dpg.set_value(status_text_id, message)

def update_filename_display(filename=None):
    if filename_text_id and dpg.does_item_exist(filename_text_id):
        if filename:
            entry_count = len(all_annotations.get(filename, []))
            bbox_count = 0
            if entry_count > 0 and selected_annotation_index != -1 and selected_annotation_index < entry_count:
                 bbox_count = len(all_annotations[filename][selected_annotation_index].get("bbox", []))

            dpg.set_value(filename_text_id, f"Editing: {filename} [Entry {selected_annotation_index + 1}/{entry_count}] [{bbox_count} bbox]")
        else:
             dpg.set_value(filename_text_id, "No image loaded")

def update_navigation_buttons():
    can_go_prev = current_image_index > 0
    can_go_next = 0 <= current_image_index < len(image_files) - 1
    if dpg.does_item_exist("prev_button"): dpg.configure_item("prev_button", enabled=can_go_prev)
    if dpg.does_item_exist("next_button"): dpg.configure_item("next_button", enabled=can_go_next)
    if dpg.does_item_exist("save_button"): dpg.configure_item("save_button", enabled=(current_image_index != -1))
    # Enable New/Delete only if an image is loaded
    has_entries = bool(all_annotations.get(get_current_filename(), []))
    if dpg.does_item_exist(new_entry_button): dpg.configure_item(new_entry_button, enabled=(current_image_index != -1))
    if dpg.does_item_exist(delete_entry_button): dpg.configure_item(delete_entry_button, enabled=(current_image_index != -1 and selected_annotation_index != -1 and has_entries))

def clear_plot_drawings(clear_image=False):
    global drawn_items
    items_to_remove = drawn_items[:]
    if clear_image and dpg.does_item_exist(drawn_image_tag): items_to_remove.append(drawn_image_tag)
    for item_tag in items_to_remove:
        if dpg.does_item_exist(item_tag): dpg.delete_item(item_tag)
    drawn_items = []
    if clear_image and drawn_image_tag in items_to_remove:
        global texture_id
        if texture_id and dpg.does_item_exist(current_texture_tag): dpg.delete_item(current_texture_tag)
        texture_id = None

# --- This also helps in deleting Bboxes, essentially refreshes the entire display ---
def draw_annotations_on_plot(): # Draws bboxes for the *selected* entry
    global drawn_items
    clear_plot_drawings(clear_image=False)
    # `rectangles` global list holds bboxes for the currently selected entry
    for rect_internal in rectangles:
        rect_tag = dpg.draw_rectangle(pmin=rect_internal['pmin'], pmax=rect_internal['pmax'], color=(255, 0, 0, 255), thickness=2, parent=plot_id, tag=dpg.generate_uuid())
        drawn_items.append(rect_tag)
    if len(points) >= 1: # Draw points for bbox being created
        point1_tag = dpg.draw_circle(center=points[0], radius=5, color=(0, 255, 0, 255), fill=(0, 255, 0, 180), parent=plot_id, tag=dpg.generate_uuid())
        drawn_items.append(point1_tag)

# --- > NEW: Function to update the UI fields based on the selected entry ---
def load_ui_from_selected_entry():
    global rectangles
    filename = get_current_filename()
    if not filename or selected_annotation_index == -1:
        reset_input_fields()
        rectangles = []
        draw_annotations_on_plot()
        update_filename_display(filename)
        return

    entries = all_annotations.get(filename, [])
    if 0 <= selected_annotation_index < len(entries):
        current_annotation_data = entries[selected_annotation_index]
        print(f"Loading UI for entry index {selected_annotation_index} of {filename}")

        # Populate UI fields (same logic as before, minus persistent fields)
        dpg.set_value(task_type_combo, current_annotation_data.get("task_type", TASK_TYPES[0]))
        dpg.set_value(text_ms_input, current_annotation_data.get("text_ms", ""))
        dpg.set_value(answer_ms_input, current_annotation_data.get("answer_ms", ""))
        dpg.set_value(text_en_input, current_annotation_data.get("text_en", ""))
        dpg.set_value(answer_en_input, current_annotation_data.get("answer_en", ""))
        dpg.set_value(split_combo, current_annotation_data.get("split", SPLIT_TYPES[0]))
        dpg.set_value(difficulty_combo, current_annotation_data.get("difficulty", DIFFICULTY_LEVELS[0]))
        dpg.set_value(tags_input, ", ".join(current_annotation_data.get("tags", [])))
        score = current_annotation_data.get("metadata", {}).get("language_quality_score", 0.0)
        dpg.set_value(lang_score_input, float(score) if score is not None else 0.0)

        # Load bounding boxes into the global `rectangles` list
        bbox_list = current_annotation_data.get("bbox", [])
        rectangles = [] # Reset global list
        for bbox in bbox_list:
            if isinstance(bbox, list) and len(bbox) == 4:
                try: xmin, ymin, xmax, ymax = map(float, bbox); rectangles.append({'pmin': (round(xmin), round(ymin)), 'pmax': (round(xmax), round(ymax))})
                except (ValueError, TypeError): print(f"Warn: Invalid bbox format: {bbox}")
            else: print(f"Warn: Invalid bbox format: {bbox}")

        draw_annotations_on_plot() # Draw the loaded bboxes
        update_filename_display(filename)
    else:
        # Index out of bounds, shouldn't happen ideally
        print(f"Error: Selected index {selected_annotation_index} out of bounds for {filename}")
        reset_input_fields()
        rectangles = []
        draw_annotations_on_plot()
        update_filename_display(filename)


# --- > NEW: Function to update the annotation data in all_annotations when UI changes ---
def update_selected_annotation_data(field_tag, new_value):
    """Updates the specific field in the currently selected annotation entry."""
    filename = get_current_filename()
    if not filename or selected_annotation_index == -1: return

    entries = all_annotations.get(filename, [])
    if 0 <= selected_annotation_index < len(entries):
        entry_data = entries[selected_annotation_index]
        # print(f"Updating field '{field_tag}' for entry {selected_annotation_index} of {filename}") # Debug

        # Map UI tag to dictionary key(s)
        if field_tag == task_type_combo: entry_data["task_type"] = new_value
        elif field_tag == text_ms_input: entry_data["text_ms"] = new_value
        elif field_tag == answer_ms_input: entry_data["answer_ms"] = new_value
        elif field_tag == text_en_input: entry_data["text_en"] = new_value
        elif field_tag == answer_en_input: entry_data["answer_en"] = new_value
        elif field_tag == split_combo: entry_data["split"] = new_value
        elif field_tag == difficulty_combo: entry_data["difficulty"] = new_value
        elif field_tag == tags_input: entry_data["tags"] = [tag.strip() for tag in new_value.split(',') if tag.strip()]
        # elif field_tag == lang_score_input:
        #      try: entry_data.setdefault("metadata", {})["language_quality_score"] = float(new_value)
        #      except (ValueError, TypeError): entry_data.setdefault("metadata", {})["language_quality_score"] = 0.0
        # Persistent fields (annotator_id, source) are handled separately if needed (e.g., when creating new)
        # BBoxes are updated elsewhere (mouse_click_callback)

    else:
        print(f"Error: Cannot update data, invalid selected index {selected_annotation_index} for {filename}")

# --- > NEW: Helper to update bboxes in the selected annotation entry ---
def update_selected_annotation_bboxes():
    filename = get_current_filename()
    if not filename or selected_annotation_index == -1: return

    entries = all_annotations.get(filename, [])
    if 0 <= selected_annotation_index < len(entries):
         entry_data = entries[selected_annotation_index]
         # Convert internal rectangles to official bbox format for storage
         bbox_list_official = [[r['pmin'][0], r['pmin'][1], r['pmax'][0], r['pmax'][1]] for r in rectangles]
         entry_data["bbox"] = bbox_list_official
         # print(f"Updated bboxes for entry {selected_annotation_index} of {filename}") # Debug
         update_filename_display(filename) # Update count in display


def reset_input_fields(): # Keep persistent fields
    global rectangles, points # Also clear drawing state
    rectangles = []
    points = []
    if dpg.does_item_exist(task_type_combo): dpg.set_value(task_type_combo, TASK_TYPES[0])
    if dpg.does_item_exist(text_ms_input): dpg.set_value(text_ms_input, "")
    if dpg.does_item_exist(answer_ms_input): dpg.set_value(answer_ms_input, "")
    if dpg.does_item_exist(text_en_input): dpg.set_value(text_en_input, "")
    if dpg.does_item_exist(answer_en_input): dpg.set_value(answer_en_input, "")
    if dpg.does_item_exist(split_combo): dpg.set_value(split_combo, SPLIT_TYPES[0])
    if dpg.does_item_exist(difficulty_combo): dpg.set_value(difficulty_combo, DIFFICULTY_LEVELS[0])
    if dpg.does_item_exist(tags_input): dpg.set_value(tags_input, "")
    if dpg.does_item_exist(lang_score_input): dpg.set_value(lang_score_input, 0.0)
    draw_annotations_on_plot() # Clear drawn boxes too

# --- > MODIFIED: Loads image, populates entry combo, loads first entry ---
def load_image_texture(image_path):
    global image_width, image_height, texture_id, points, rectangles
    global display_width, display_height, current_image_index, selected_annotation_index

    # --- > Save changes to previous image's selected entry before switching? (Optional but safer)
    # update_selected_annotation_data(...) # Call this for all fields if needed, or rely on callbacks having updated it

    clear_plot_drawings(clear_image=True)
    points, rectangles = [], []
    selected_annotation_index = -1 # Reset selection

    if not os.path.exists(image_path):
        update_status(f"Error: Image file not found at {image_path}")
        update_filename_display(None); reset_input_fields()
        # Clear annotation entry combo
        if dpg.does_item_exist(annotation_entry_combo): dpg.configure_item(annotation_entry_combo, items=[], default_value=None)
        return False

    current_filename = os.path.basename(image_path)

    try:
        # Load image, calculate display size, prepare texture (same as before)
        img = Image.open(image_path).convert("RGBA"); new_image_width, new_image_height = img.size
        image_width, image_height = float(new_image_width), float(new_image_height)
        if image_height <= MIN_PLOT_HEIGHT: display_height, display_width = image_height, image_width
        else: scale_factor = MIN_PLOT_HEIGHT / image_height; display_height, display_width = MIN_PLOT_HEIGHT, image_width * scale_factor
        display_width, display_height = math.floor(display_width), math.floor(display_height)
        img_data = np.array(img, dtype=np.float32) / 255.0; img_data_flat = img_data.ravel().tolist()
        if not dpg.does_item_exist(texture_registry_id): dpg.add_texture_registry(tag=texture_registry_id)
        if dpg.does_item_exist(current_texture_tag): dpg.delete_item(current_texture_tag)
        texture_id = dpg.add_static_texture(width=new_image_width, height=new_image_height, default_value=img_data_flat, tag=current_texture_tag, parent=texture_registry_id)

        # Update plot, axes, draw image (same as before)
        if plot_id and dpg.does_item_exist(plot_id):
            dpg.configure_item(plot_id, width=display_width, height=display_height)
            if xaxis_id and dpg.does_item_exist(xaxis_id): dpg.set_axis_limits(xaxis_id, 0.0, image_width)
            if yaxis_id and dpg.does_item_exist(yaxis_id): dpg.set_axis_limits(yaxis_id, image_height, 0.0)
            dpg.draw_image(texture_tag=current_texture_tag, pmin=(0.0, 0.0), pmax=(image_width, image_height), uv_min=(0, 1), uv_max=(1, 0), parent=plot_id, tag=drawn_image_tag)

            # --- > Populate Annotation Entry Combo Box ---
            entry_list = all_annotations.get(current_filename, [])
            entry_ids = [entry.get("image_id", f"Entry_{i+1}") for i, entry in enumerate(entry_list)] # Use image_id for display

            if dpg.does_item_exist(annotation_entry_combo):
                dpg.configure_item(annotation_entry_combo, items=entry_ids)
                if entry_ids:
                    # Select and load the first entry by default
                    selected_annotation_index = 0
                    dpg.set_value(annotation_entry_combo, entry_ids[0])
                    load_ui_from_selected_entry() # Load data for index 0
                else:
                    # No entries exist, clear fields and selection
                    selected_annotation_index = -1
                    dpg.set_value(annotation_entry_combo, None) # Clear combo selection
                    reset_input_fields()
                    draw_annotations_on_plot() # Ensure plot is clear of bboxes
            else:
                print("Error: Annotation entry combo box not found.")
                selected_annotation_index = -1
                reset_input_fields()


            # Update window size
            controls_height_approx = 520 # Needs more space for combo/buttons
            window_padding_width = 80
            new_win_width = display_width + window_padding_width; new_win_height = display_height + controls_height_approx
            min_win_width, min_win_height = 700, 800 # Min size increase
            if dpg.does_item_exist(main_window_tag): dpg.configure_item(main_window_tag, width=max(new_win_width, min_win_width), height=max(new_win_height, min_win_height))

            # Update status and filename display (will reflect loaded entry)
            update_status(f"Loaded {current_filename} ({current_image_index + 1}/{len(image_files)}). Select annotation entry or add new.")
            update_filename_display(current_filename)
            update_navigation_buttons() # Update delete button state etc.
            return True
        else: # Plot doesn't exist
             update_status("Error: Plot area not found."); update_filename_display(None); reset_input_fields(); return False

    except Exception as e:
        update_status(f"Error loading image {current_filename}: {e}"); update_filename_display(None); reset_input_fields(); print(f"Error loading image: {e}")
        if dpg.does_item_exist(current_texture_tag): dpg.delete_item(current_texture_tag)
        texture_id, image_width, image_height, display_width, display_height = None, 0, 0, 0, 0
        rectangles, points = [], []; selected_annotation_index = -1
        if dpg.does_item_exist(annotation_entry_combo): dpg.configure_item(annotation_entry_combo, items=[], default_value=None)
        return False

# --- Callbacks ---

def directory_selected_callback(sender, app_data):
    global image_files, current_image_index, selected_directory, points, rectangles, selected_annotation_index
    if app_data['file_path_name']:
        selected_directory = app_data['file_path_name']
        dpg.set_value("directory_text", f"Selected: {selected_directory}")
        print(f"Selected directory: {selected_directory}")
        
        # Pull latest changes from Github First
        pull_annotations_repo()
        # --- 1. Load annotations from Github wala Repo ---
        grouped_git_annotations = defaultdict(list)
        with open(os.path.join(GIT_OUTPUT_DIR, GIT_ANNOTATION_FILENAME), 'r') as f:
            loaded_list = json.load(f)
        for item in loaded_list:
                image_path = item.get("image_path", "")
                image_id = item.get("image_id")

                if not image_path or not image_id:
                    print(f"Warning: Skipping annotation due to missing image_path/image_id: {item}")
                    continue

                # # Basic check for overall duplicate image_ids
                # if image_id in image_ids_seen_overall:
                #      print(f"Warning: Duplicate image_id '{image_id}' found across dataset. Check data integrity. Skipping duplicate entry.")
                #      continue
                # image_ids_seen_overall.add(image_id)

                # Derive filename (handle potential path separator differences)
                filename = os.path.basename(image_path.replace(f"{IMAGE_SUBDIR}/", "").replace(f"{IMAGE_SUBDIR}\\", ""))
                if not filename:
                    print(f"Warning: Could not derive filename from image_path: {image_path}")
                    continue

                grouped_git_annotations[filename].append(item)
        all_git_annotations = dict(grouped_git_annotations)

        # --- 2. Get initial list of image files ---
        initial_image_files = []
        for ext in SUPPORTED_EXTENSIONS:
            initial_image_files.extend(glob.glob(os.path.join(selected_directory, f"*{ext}")))
            initial_image_files.extend(glob.glob(os.path.join(selected_directory, f"*{ext.upper()}")))
        initial_image_files = sorted(list(set(initial_image_files)))

        if not initial_image_files:
            update_status(f"No supported images found in {selected_directory}")
            update_filename_display(None); current_image_index = -1; points, rectangles, selected_annotation_index = [], [], -1
            clear_plot_drawings(clear_image=True); reset_input_fields()
            if dpg.does_item_exist(annotation_entry_combo): dpg.configure_item(annotation_entry_combo, items=[], default_value=None)
            update_navigation_buttons() # Update buttons state
            return # Exit if no images found

        print(f"Found {len(initial_image_files)} images initially.")

        # --- 3. Get set of filenames already annotated ---
        annotated_filenames = set(all_git_annotations.keys())
        print(f"Found {len(annotated_filenames)} filenames in existing annotations.")

        # --- 4. Iterate and Rename files IF needed ---
        renamed_files_map = {} # Optional: track renames {old_path: new_path}
        processed_image_files = [] # Build the final list of paths to use

        print("Checking for filename conflicts with annotated files...")
        for idx, current_path in enumerate(initial_image_files):
            current_filename = os.path.basename(current_path)

            if current_filename in annotated_filenames:
                # This filename exists in annotations, needs potential renaming
                print(f"  Conflict check: '{current_filename}' found in annotations. Checking for rename...")
                base_name, ext = os.path.splitext(current_filename)
                suffix = 1
                while True:
                    new_filename = f"{base_name}_{suffix}{ext}"
                    new_path = os.path.join(selected_directory, new_filename)
                    # Check if the NEW proposed path exists on disk
                    if not os.path.exists(new_path):
                        # Found a unique name, perform rename
                        try:
                            print(f"    Renaming '{current_filename}' to '{new_filename}'...")
                            os.rename(current_path, new_path)
                            renamed_files_map[current_path] = new_path
                            processed_image_files.append(new_path) # Use the new path
                            # --- > CRITICAL: Remove the new name from annotated_filenames set
                            # if it was there, to prevent a file renamed TO this from
                            # triggering another rename later in the loop.
                            annotated_filenames.discard(new_filename)

                        except OSError as e:
                            print(f"    Error renaming file '{current_filename}': {e}. Using original path.")
                            processed_image_files.append(current_path) # Keep original path if rename fails
                        break # Exit while loop for this file
                    else:
                        # New path already exists, increment suffix and try again
                        print(f"    '{new_filename}' already exists, trying next suffix...")
                        suffix += 1
            else:
                # No conflict with annotations, use the original path
                processed_image_files.append(current_path)
                # Add this filename to annotated_filenames conceptually, so if we encounter
                # another file later that *would* be renamed to this, we avoid it.
                # However, the primary check is os.path.exists, so this might be redundant.
                # Let's rely on the os.path.exists check within the renaming loop.

        # --- 5. Update the global image_files list ---
        image_files = processed_image_files # Use the potentially renamed list
        if renamed_files_map:
             print(f"Finished renaming {len(renamed_files_map)} file(s).")
        else:
             print("No filename conflicts found requiring rename.")


        # --- 6. Determine starting index (using the potentially renamed image_files list) ---
        start_index = 0
        # --- > Re-check against all_annotations keys using the *final* filenames ---
        for idx, img_path in enumerate(image_files):
            filename = os.path.basename(img_path)
            # Check if filename is NOT in annotations or if its entry list IS empty
            if filename not in all_annotations or not all_annotations.get(filename):
                start_index = idx
                print(f"Starting at first unannotated image: {filename} (index {start_index})")
                break
        else: # Loop completed without break
             print("All images seem to have existing annotations. Starting at the first image.")
             start_index = 0


        # --- 7. Load the starting image ---
        current_image_index = start_index
        load_image_texture(image_files[current_image_index]) # Loads image & potentially its first entry

        update_navigation_buttons() # Update button states based on final setup
    else:
        print("Directory selection cancelled.")


def mouse_click_callback(sender, app_data): # Modifies `rectangles` and updates selected entry's bbox
    global points, rectangles
    if app_data == dpg.mvMouseButton_Left and current_image_index != -1 and selected_annotation_index != -1: # Need entry selected
        if plot_id and dpg.is_item_hovered(plot_id):
            plot_pos = dpg.get_plot_mouse_pos()
            x = max(0.0, min(plot_pos[0], image_width)); y = max(0.0, min(plot_pos[1], image_height))
            clicked_point = (round(x), round(y))
            points.append(clicked_point)
            if len(points) == 1:
                draw_annotations_on_plot(); update_status(f"First bbox point: {points[0]}. Click again.")
            elif len(points) == 2:
                p1, p2 = points[0], points[1]; p_min = (min(p1[0], p2[0]), min(p1[1], p2[1])); p_max = (max(p1[0], p2[0]), max(p1[1], p2[1]))
                rectangles.append({'pmin': p_min, 'pmax': p_max}) # Add to current list
                print(f"Added bbox: {p_min} -> {p_max}")
                points = []; draw_annotations_on_plot()
                update_selected_annotation_bboxes() # <--- Update the data in all_annotations
                update_status(f"Bbox added ({len(rectangles)} total). Click for new one.")
                # Filename display updates in update_selected_annotation_bboxes via update_filename_display
    elif selected_annotation_index == -1 and current_image_index != -1:
         update_status("Please select or create an annotation entry before adding bounding boxes.")


# Persistent Field Callbacks
def annotator_id_callback(sender, app_data): global annotator_id_value; annotator_id_value = app_data
def source_callback(sender, app_data): global source_value; source_value = app_data

# --- > NEW: Validation Function ---
def validate_current_entry():
    """Checks if the currently selected annotation entry has required fields filled."""
    filename = get_current_filename()

    # --- First, check persistent global fields ---
    if not annotator_id_value.strip():
        msg = "Validation Error: Please enter an Annotator ID first."
        update_status(msg)
        print(msg)
        # Consider focusing the annotator_id_input field if possible/desired
        # if dpg.does_item_exist(annotator_id_input): dpg.focus_item(annotator_id_input)
        return False

    if not source_value.strip():
        msg = "Validation Error: Please enter a Source first."
        update_status(msg)
        print(msg)
        # if dpg.does_item_exist(source_input): dpg.focus_item(source_input)
        return False

    # --- Then, check fields for the currently selected entry (if any) ---
    if not filename or selected_annotation_index == -1:
        # No image loaded or no entry selected, nothing specific to validate for switching.
        # Global fields already checked.
        return True

    entries = all_annotations.get(filename, [])
    if 0 <= selected_annotation_index < len(entries):
        entry_data = entries[selected_annotation_index]
        entry_id = entry_data.get("image_id", f"index {selected_annotation_index}")

        error_messages = []

        # Check text_ms OR text_en
        text_ms = entry_data.get("text_ms", "").strip()
        text_en = entry_data.get("text_en", "").strip()
        if not text_ms and not text_en:
            error_messages.append("Malay Text OR English Text must be provided")

        # Check bbox (using the data stored in all_annotations, which should be up-to-date)
        if not entry_data.get("bbox", []):
            error_messages.append("At least one Bounding Box must be defined")

        # Check tags
        if not entry_data.get("tags", []):
             error_messages.append("At least one Tag must be provided")

        # --- Add other checks as needed ---
        # e.g., if answer is required for VQA task type:
        # if entry_data.get("task_type") == "vqa":
        #     if not entry_data.get("answer_ms", "").strip() and not entry_data.get("answer_en", "").strip():
        #          error_messages.append("Answer (Malay or English) required for VQA task type")

        if error_messages:
            full_error_msg = f"Validation Error on '{entry_id}': {'; '.join(error_messages)}."
            update_status(full_error_msg)
            print(full_error_msg)
            return False
        else:
            # All checks passed for this entry
            # print(f"Validation passed for entry '{entry_id}'") # Debug
            return True
    else:
        # Index is invalid, technically shouldn't happen if selection is managed correctly
        print(f"Validation Warning: Invalid selected index ({selected_annotation_index}) for {filename}. Allowing action.")
        return True # Allow action if state is inconsistent

    return True # Default pass if no entry selected etc.

# --- > NEW: Callback for Annotation Entry Selection ---
def annotation_entry_selected_callback(sender, app_data):
    global selected_annotation_index, points
    filename = get_current_filename()
    if not filename: return

    # Find the index of the *target* selection
    entries = all_annotations.get(filename, [])
    selected_id = app_data
    target_index = -1
    for i, entry in enumerate(entries):
        if entry.get("image_id") == selected_id:
            target_index = i
            break

    if target_index != -1 and target_index != selected_annotation_index:
         # --- > VALIDATION CHECK (Before switching FROM the current entry) ---
         if not validate_current_entry():
             # Validation failed on the *current* entry, revert combo selection back
             current_selected_id = None
             if 0 <= selected_annotation_index < len(entries):
                 current_selected_id = entries[selected_annotation_index].get("image_id")

             if current_selected_id and dpg.does_item_exist(annotation_entry_combo):
                 # Setting value might trigger callback again, be careful, maybe disable/enable needed?
                 # For now, just set it back. If it causes loops, more complex handling needed.
                 dpg.set_value(annotation_entry_combo, current_selected_id)
             print("Switch cancelled due to validation failure on current entry.")
             return # Stop the switch

         # Validation passed, proceed with switching
         print(f"Switching to annotation entry index: {target_index}")
         selected_annotation_index = target_index
         points = []
         load_ui_from_selected_entry()
         update_navigation_buttons()
    elif target_index == -1:
        print(f"Warning: Selected entry ID '{selected_id}' not found during switch.")

# --- > NEW: Callback for "New Annotation Entry" button ---
def new_annotation_entry_callback():
    global selected_annotation_index, all_annotations, points, rectangles
    filename = get_current_filename()
    if not filename:
        update_status("Load an image first to add an annotation entry.")
        return

    # --- > VALIDATION CHECK (Before creating new, check the current one) ---
    if selected_annotation_index != -1: # Only validate if an entry is currently selected
        if not validate_current_entry():
            return # Stop if validation fails on the current entry

    # ... (rest of the new entry creation logic remains the same) ...
    # Determine the next available ID suffix (_N)
    entries = all_annotations.get(filename, [])
    existing_suffixes = []
    base_id = os.path.splitext(filename)[0]
    for entry in entries:
        entry_id = entry.get("image_id", "")
        if entry_id.startswith(base_id + "_"):
            try: existing_suffixes.append(int(entry_id.split('_')[-1]))
            except ValueError: pass

    next_suffix = max(existing_suffixes) + 1 if existing_suffixes else 1
    new_image_id = f"{base_id}_{next_suffix}"
    timestamp = datetime.datetime.now(datetime.timezone.utc).strftime("%Y-%m-%dT%H:%M:%S") + 'Z'
    image_path = f"{IMAGE_SUBDIR}/{filename}"

    new_entry_data = {
        "image_id": new_image_id, "image_path": image_path, "task_type": TASK_TYPES[0],
        "text_ms": "", "answer_ms": "", "text_en": "", "answer_en": "",
        "language": {"source": ["ms", "en"], "target": ["ms", "en"]},
        "source": source_value, "split": SPLIT_TYPES[0], "difficulty": DIFFICULTY_LEVELS[0],
        "tags": [], "bbox": [],
        "metadata": { "license": "CC-BY-SA", "annotator_id": annotator_id_value,
                     "language_quality_score": 10.0, "timestamp": timestamp }
    }

    if filename not in all_annotations: all_annotations[filename] = []
    all_annotations[filename].append(new_entry_data)

    new_entry_list = all_annotations[filename]
    new_entry_ids = [entry.get("image_id", f"Entry_{i+1}") for i, entry in enumerate(new_entry_list)]
    if dpg.does_item_exist(annotation_entry_combo):
        dpg.configure_item(annotation_entry_combo, items=new_entry_ids)
        selected_annotation_index = len(new_entry_list) - 1
        dpg.set_value(annotation_entry_combo, new_image_id)
        print(f"Created and selected new entry: {new_image_id} (index {selected_annotation_index})")
        points = []
        reset_input_fields()
        load_ui_from_selected_entry() # Loads defaults + draws empty bboxes
        update_status(f"Created new annotation entry '{new_image_id}'.")
        update_navigation_buttons()
    else: print("Error: Annotation entry combo box not found during new entry creation.")


# --- > NEW: Callback for "Delete Selected Entry" button ---
def delete_selected_entry_callback():
    global selected_annotation_index, all_annotations, rectangles, points
    filename = get_current_filename()
    if not filename or selected_annotation_index == -1:
        update_status("No annotation entry selected to delete.")
        return

    entries = all_annotations.get(filename, [])
    if 0 <= selected_annotation_index < len(entries):
        deleted_id = entries[selected_annotation_index].get("image_id", f"index {selected_annotation_index}")
        print(f"Deleting annotation entry: {deleted_id}")

        # Remove from the list in all_annotations
        del entries[selected_annotation_index]

        # Update UI Combo Box
        remaining_entry_ids = [entry.get("image_id", f"Entry_{i+1}") for i, entry in enumerate(entries)]
        if dpg.does_item_exist(annotation_entry_combo):
            dpg.configure_item(annotation_entry_combo, items=remaining_entry_ids)

            # Select the previous entry or reset if list is empty
            if entries:
                selected_annotation_index = max(0, selected_annotation_index - 1) # Select previous or first
                new_selected_id = remaining_entry_ids[selected_annotation_index]
                dpg.set_value(annotation_entry_combo, new_selected_id)
                load_ui_from_selected_entry() # Load the newly selected entry
                update_status(f"Deleted entry '{deleted_id}'. Switched to '{new_selected_id}'.")
            else:
                # List is now empty
                selected_annotation_index = -1
                dpg.set_value(annotation_entry_combo, None)
                reset_input_fields()
                rectangles = []
                points = []
                draw_annotations_on_plot()
                update_status(f"Deleted entry '{deleted_id}'. No entries remaining for this image.")

            update_navigation_buttons() # Update delete button state etc.
            update_filename_display(filename) # Update counts

        else:
             print("Error: Annotation entry combo box not found during delete.")

    else:
        print(f"Error: Cannot delete, invalid selected index {selected_annotation_index}")
        update_status("Error: Invalid selection to delete.")

# --- > MODIFIED: Save flattens the structure ---
def save_annotations_callback():
    global all_annotations
    if not all_annotations:
        update_status("No annotations available to save.")
        return

    # --- > Ensure current edits are potentially saved back (if not using callbacks)
    # You might want to explicitly gather current UI state and update the selected entry here
    # if you don't trust the individual field callbacks to have kept all_annotations up-to-date.
    # For now, assuming field callbacks handled it. BBoxes are updated via update_selected_annotation_bboxes().

    # Flatten the dictionary values (lists of annotations) into a single list
    list_to_save = []
    image_ids_in_list = set()
    valid_save = True
    for filename, entries in all_annotations.items():
        for entry in entries:
            entry_id = entry.get("image_id")
            if entry_id in image_ids_in_list:
                 msg = f"Save Error: Duplicate image_id '{entry_id}' found in data. Resolve conflicts."
                 print(msg); update_status(msg); valid_save = False; break
            image_ids_in_list.add(entry_id)
            list_to_save.append(entry)
        if not valid_save: break

    if not valid_save:
        print("Save aborted due to duplicate image IDs.")
        return

    if not list_to_save:
        update_status("No annotations found to save.")
        return

    try:
        filepath = get_annotation_filepath(); create_output_dir()
        with open(filepath, 'w') as f: json.dump(list_to_save, f, indent=4)
        msg = f"All {len(list_to_save)} annotations saved successfully to {filepath}"
        update_status(msg); print(msg)
    except Exception as e:
        msg = f"Error saving annotations file: {e}"; update_status(msg); print(msg)
        import traceback; traceback.print_exc()


# --- > NEW: Callback for "Remove Last BBox" button ---
def remove_last_bbox_callback():
    """Removes the last added bounding box from the current internal list,
       updates the plot, and updates the stored data."""
    global rectangles # We directly modify the list for the selected entry

    if current_image_index == -1 or selected_annotation_index == -1:
        update_status("No annotation entry selected to remove bounding box from.")
        return

    if rectangles: # Check if there are any rectangles to remove
        removed_bbox = rectangles.pop() # Remove the last element
        print(f"Removed last bounding box: {removed_bbox}")

        # Update the plot display
        draw_annotations_on_plot()

        # Update the stored bbox data in all_annotations for the selected entry
        update_selected_annotation_bboxes()

        # Update status
        update_status(f"Removed last bounding box. {len(rectangles)} remaining.")
        # update_filename_display will be called by update_selected_annotation_bboxes

    else:
        update_status("No bounding boxes to remove for the selected entry.")
        print("No bounding boxes to remove.")


def clear_callback(): # Clears the *selected* annotation entry
    global points, rectangles, selected_annotation_index
    if current_image_index != -1 and selected_annotation_index != -1:
        print(f"Clearing currently selected annotation entry (index {selected_annotation_index}).")
        # Effectively delete and create new, or just reset fields? Let's just reset fields.
        # To delete, call delete_selected_entry_callback() instead.
        # For resetting:
        filename = get_current_filename()
        entries = all_annotations.get(filename, [])
        if 0 <= selected_annotation_index < len(entries):
            # Reset data in the dictionary (except IDs, paths, persistent fields)
            entry_data = entries[selected_annotation_index]
            entry_data["task_type"]= TASK_TYPES[0]; entry_data["text_ms"]= ""; entry_data["answer_ms"]= ""
            entry_data["text_en"]= ""; entry_data["answer_en"]= ""; entry_data["split"]= SPLIT_TYPES[0]
            entry_data["difficulty"]= DIFFICULTY_LEVELS[0]; entry_data["tags"]= []; entry_data["bbox"]= []
            entry_data.setdefault("metadata", {})["language_quality_score"] = 0.0
            # Regenerate timestamp? Or keep original creation? Let's keep original for now.
            # entry_data["metadata"]["timestamp"] = datetime.datetime.now(datetime.timezone.utc).strftime("%Y-%m-%dT%H:%M:%S") + 'Z'

            # Reset UI and drawing state
            points = []; rectangles = []
            reset_input_fields() # Resets UI fields
            load_ui_from_selected_entry() # Reloads the now reset data
            update_status(f"Cleared data for selected entry. BBoxes removed.")
            update_filename_display(filename)
        else:
             update_status("Cannot clear: Invalid selection.")
    elif current_image_index == -1:
         update_status("No image loaded to clear.")
    else:
         update_status("No annotation entry selected to clear.")


def next_image_callback():
    global current_image_index
    # --- > VALIDATION CHECK ---
    if not validate_current_entry():
        return # Stop if validation fails

    if current_image_index < len(image_files) - 1:
        current_image_index += 1
        # Save images:
        save_annotations_callback() #Autosave to JSON
        load_image_texture(image_files[current_image_index])

def prev_image_callback():
    global current_image_index
    # --- > VALIDATION CHECK ---
    if not validate_current_entry():
        return # Stop if validation fails

    if current_image_index > 0:
        current_image_index -= 1
        save_annotations_callback() #Autosave to JSON
        load_image_texture(image_files[current_image_index])


# --- > RENAMED and MODIFIED: Function to run on exit ---
def housekeeping_work_on_exit():
    """Moves images with existing annotations to an 'annotated' subfolder, and pushes annotations to github"""

    # Moving annotated Images
    print("Exit callback triggered: Checking for annotated images to move...")

    if not selected_directory:
        print("No directory was selected. Skipping image move or git update.")
        return

    if not all_annotations:
        print("No annotations found in memory. Nothing to move or update in main.")
        return

    target_dir = os.path.join(selected_directory, "annotated")

    try:
        os.makedirs(target_dir, exist_ok=True)
        print(f"Ensured 'annotated' directory exists at: {target_dir}")

        moved_count = 0 # Renamed counter
        skipped_count = 0

        # Use list(all_annotations.keys()) to avoid issues if modifying dict during iteration (though unlikely here)
        for filename in list(all_annotations.keys()):
            if all_annotations.get(filename): # Check for non-empty entry list
                source_path = os.path.join(selected_directory, filename)
                dest_path = os.path.join(target_dir, filename)

                if os.path.exists(source_path):
                    try:
                        # --- > Use shutil.move instead of copy2 <---
                        print(f"Moving '{filename}' to '{target_dir}'...")
                        shutil.move(source_path, dest_path)
                        moved_count += 1 # Updated counter name
                    # Handle potential error if destination already exists (though shouldn't happen with unique names)
                    except FileExistsError:
                         print(f"  Skipping '{filename}': File already exists in destination '{target_dir}'.")
                         skipped_count += 1
                    except Exception as move_err:
                        print(f"  Error moving '{filename}': {move_err}")
                        skipped_count += 1
                else:
                    # This case is less likely if the image was just loaded, but good to keep
                    print(f"  Skipping '{filename}': Source file not found at '{source_path}'.")
                    skipped_count += 1

        print("-" * 20)
        if moved_count > 0:
            # Updated print statement
            print(f"Successfully moved {moved_count} annotated image(s) to '{target_dir}'.")
        if skipped_count > 0:
             print(f"Skipped {skipped_count} image(s) due to errors or missing source.")
        if moved_count == 0 and skipped_count == 0:
            print("No annotated images needed moving (or none found).")
        print("-" * 20)

    except Exception as e:
        print(f"An error occurred during the image moving process: {e}")

    print("Pushing annotation changes to master")
    # Compiling changes and pushing annotations to Git Main
    # First pull latest changes
    pull_annotations_repo()
    # Then load annotations file
    git_annot_filepath = os.path.join(GIT_OUTPUT_DIR,GIT_ANNOTATION_FILENAME) 
    with open(git_annot_filepath, 'r') as file:
        git_annotations = json.load(file)
    # Then add all the existing annotations from temp_annotations into git_annotations
    temp_annot_filepath = os.path.join(OUTPUT_DIR, ANNOTATION_FILENAME)
    with open(temp_annot_filepath, 'r') as file2:
        temp_annotations = json.load(file2)
    for i in temp_annotations:
        git_annotations.append(i)
    # Then dump git_annotations json file:
    with open(git_annot_filepath, 'w') as f: json.dump(git_annotations, f, indent=4)
    # Commit changes to the new item
    repo = git.Repo(GIT_OUTPUT_DIR)
    files = repo.git.diff(None, name_only = True)
    for f in files.split('\n'):
        repo.git.add(f)
    repo.git.commit("-m","Annotations Added")
    # Then Push changes to github
    repo.remotes.origin.push()
    # Completed Work
    print("New annotations added to Annotations Github")
    
    # Delete test_annotations folder
    shutil.rmtree(OUTPUT_DIR)


# --- DPG Setup ---
dpg.create_context()
dpg.add_texture_registry(tag=texture_registry_id)
load_existing_annotations()

with dpg.file_dialog(directory_selector=True, show=False, callback=directory_selected_callback, tag=directory_dialog_tag, width=700 ,height=400):
    dpg.add_file_extension(".*")

initial_plot_width = math.floor(MIN_PLOT_HEIGHT * (16.0/9.0))
initial_plot_height = int(MIN_PLOT_HEIGHT)
initial_window_width = initial_plot_width + 100
initial_window_height = initial_plot_height + 550 # Needs more space

with dpg.window(label="Image Annotator (Multi-Entry)", width=initial_window_width, height=initial_window_height, tag=main_window_tag):

    # Top Row: Directory, Annotator ID, Source
    with dpg.group(horizontal=True):
        dpg.add_button(label="Select Image Directory", callback=lambda: dpg.show_item(directory_dialog_tag))
        dpg.add_text("Selected: None", tag="directory_text")
        dpg.add_spacer(width=20)
        dpg.add_text("Annotator ID:")
        dpg.add_input_text(tag=annotator_id_input, default_value=annotator_id_value, width=120, callback=annotator_id_callback)
        dpg.add_spacer(width=20)
        dpg.add_text("Source Of Images:")
        dpg.add_input_text(tag=source_input, default_value=source_value, width=150, callback=source_callback)

    dpg.add_separator()
    filename_text_id = dpg.add_text("No image loaded", color=(200, 200, 50))
    dpg.add_separator()
    status_text_id = dpg.add_text("Select an image directory to begin.")

    # --- > Mid Row 1: Annotation Entry Management ---
    with dpg.group(horizontal=True):
        dpg.add_text("Annotation Entry:")
        dpg.add_combo([], width=250, tag=annotation_entry_combo, callback=annotation_entry_selected_callback, default_value=None, no_preview=True)
        dpg.add_button(label="New Entry", tag=new_entry_button, callback=new_annotation_entry_callback, enabled=False)
        dpg.add_button(label="Delete Selected Entry", tag=delete_entry_button, callback=delete_selected_entry_callback, enabled=False)

    # Mid Row 2: Save/Clear/Nav Buttons
    with dpg.group(horizontal=True):
        dpg.add_button(label="Save All Annotations", callback=save_annotations_callback, tag="save_button", enabled=False)
        dpg.add_button(label="Remove Last BBox", callback=remove_last_bbox_callback, tag="remove_last_bbox_button")
        dpg.add_button(label="Clear Selected Entry Data", callback=clear_callback, tag="clear_button") # Clarified label
        dpg.add_button(label="<< Previous Image", callback=prev_image_callback, tag="prev_button", enabled=False)
        dpg.add_button(label="Next Image >>", callback=next_image_callback, tag="next_button", enabled=False)

    dpg.add_separator()

    # Plot Area
    plot_id = dpg.add_plot(label="Image Plot - Click to define bounding boxes for selected entry", height=initial_plot_height, width=initial_plot_width, tag=plot_id, no_title=False, no_menus=True, no_box_select=True, no_mouse_pos=True, equal_aspects=True)
    xaxis_id = dpg.add_plot_axis(dpg.mvXAxis, label="", parent=plot_id, no_gridlines=True, no_tick_marks=True, no_tick_labels=True, tag=xaxis_id)
    dpg.set_axis_limits(xaxis_id, 0.0, float(initial_plot_width))
    yaxis_id = dpg.add_plot_axis(dpg.mvYAxis, label="", parent=plot_id, no_gridlines=True, no_tick_marks=True, no_tick_labels=True, tag=yaxis_id)
    dpg.set_axis_limits(yaxis_id, float(initial_plot_height), 0.0)

    dpg.add_separator()

    # --- > Annotation Input Fields Area (Callbacks added for auto-update) ---
    dpg.add_text("Annotation Details (for selected entry):")
    with dpg.group(horizontal=True):
        dpg.add_text("Task Type:")
        dpg.add_combo(TASK_TYPES, default_value=TASK_TYPES[0], width=150, tag=task_type_combo, callback=update_selected_annotation_data)
        dpg.add_spacer(width=20); dpg.add_text("Split:")
        dpg.add_combo(SPLIT_TYPES, default_value=SPLIT_TYPES[0], width=100, tag=split_combo, callback=update_selected_annotation_data)
        dpg.add_spacer(width=20); dpg.add_text("Difficulty:")
        dpg.add_combo(DIFFICULTY_LEVELS, default_value=DIFFICULTY_LEVELS[0], width=100, tag=difficulty_combo, callback=update_selected_annotation_data)
        # dpg.add_spacer(width=20); dpg.add_text("Lang. Score:")
        # dpg.add_input_float(width=80, default_value=0.0, step=0.1, format="%.1f", tag=lang_score_input, callback=update_selected_annotation_data)

    # Text Inputs (with callbacks)
    with dpg.group(horizontal=True):
        with dpg.group():
            dpg.add_text("Malay Text:")
            dpg.add_input_text(hint="Question / Instruction / Caption (Malay)", width=400, multiline=True, height=60, tag=text_ms_input, callback=update_selected_annotation_data)
            dpg.add_text("Malay Answer (if applicable):")
            dpg.add_input_text(hint="Answer (Malay)", width=400, multiline=True, height=60, tag=answer_ms_input, callback=update_selected_annotation_data)
        dpg.add_spacer(width=20)
        with dpg.group():
             dpg.add_text("English Text:")
             dpg.add_input_text(hint="Question / Instruction / Caption (English)", width=400, multiline=True, height=60, tag=text_en_input, callback=update_selected_annotation_data)
             dpg.add_text("English Answer (if applicable):")
             dpg.add_input_text(hint="Answer (English)", width=400, multiline=True, height=60, tag=answer_en_input, callback=update_selected_annotation_data)

    # Tags Input (with callback)
    dpg.add_text("Tags:")
    dpg.add_input_text(hint="Comma-separated tags (e.g., animal, outdoor, cat)", width=-1, tag=tags_input, callback=update_selected_annotation_data)


# Mouse handler
with dpg.handler_registry():
    dpg.add_mouse_click_handler(button=dpg.mvMouseButton_Left, callback=mouse_click_callback)

# --- DPG Viewport and Execution ---
dpg.create_viewport(title='Dear PyGui Multi-Entry Annotator', width=initial_window_width+20, height=initial_window_height+20, resizable=True)
dpg.setup_dearpygui()
dpg.set_exit_callback(housekeeping_work_on_exit)
dpg.show_viewport()
dpg.set_primary_window(main_window_tag, True)
dpg.start_dearpygui()
dpg.destroy_context()


# DONE:
# Implemented a method to remove the last bounding box drawn on the image
# Add the ability to track every image that has ever been annotated using this app
#   - Implement by running a check script in the beginning that renames images in the selected directory as necessary first, before annotating the images in case of conflicts
# Add method to pull latest version of annotations and push latest version of the same

# References Used for this:
# https://dearpygui.readthedocs.io
# https://gitpython.readthedocs.io
# https://stackoverflow.com/questions/40633097/gitpython-command-syntax-for-git-commit
# https://stackoverflow.com/questions/41429525/how-to-push-to-remote-repo-with-gitpython